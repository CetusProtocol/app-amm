function A(t){return"connect"in t}function g(t){return!A(t)}function d(t){return t.flatMap(r=>g(r)?r.get():r)}var W="Sui Wallet";function w(t,r){return[...r.map(u=>t.find(l=>l.name===u)).filter(Boolean),...t.filter(u=>!r.includes(u.name))]}function T({adapters:t,preferredWallets:r=[W]}){const u=new Set;let l=null,n={accounts:[],currentAccount:null,wallets:w(d(t),r),currentWallet:null,status:"DISCONNECTED"};const i=()=>({...n,isConnecting:n.status==="CONNECTING",isConnected:n.status==="CONNECTED",isError:n.status==="ERROR"});let o=i();function s(e){n={...n,...e},o=i(),u.forEach(c=>{try{c(o)}catch{}})}function E(){l&&(l(),l=null),s({status:"DISCONNECTED",accounts:[],currentAccount:null,currentWallet:null})}const f=t.filter(g);return f.length&&f.map(e=>e.on("changed",()=>{s({wallets:w(d(t),r)})})),{getState(){return o},subscribe(e){u.add(e);try{e(o)}catch{}return()=>{u.delete(e)}},async connect(e){var N,C;const c=(N=n.wallets.find(a=>a.name===e))!=null?N:null;if(s({currentWallet:c}),c&&!c.connecting){l&&l(),l=c.on("change",({connected:a})=>{a===!1&&E()});try{s({status:"CONNECTING"}),await c.connect(),s({status:"CONNECTED"});const a=await c.getAccounts();s({accounts:a,currentAccount:(C=a[0])!=null?C:null})}catch(a){console.log("Wallet connection error",a),s({status:"ERROR"})}}else s({status:"DISCONNECTED"})},async disconnect(){if(!n.currentWallet){console.warn("Attempted to `disconnect` but no wallet was connected.");return}await n.currentWallet.disconnect(),E()},signAndExecuteTransaction(e,c){if(!n.currentWallet)throw new Error("No wallet is currently connected, cannot call `signAndExecuteTransaction`.");return n.currentWallet.signAndExecuteTransaction(e,c)}}}export{T as c};
