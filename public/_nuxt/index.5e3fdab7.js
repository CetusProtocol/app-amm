function A(t){return"connect"in t}function g(t){return!A(t)}function d(t){return t.flatMap(c=>g(c)?c.get():c)}var W="Sui Wallet";function w(t,c){return[...c.map(u=>t.find(r=>r.name===u)).filter(Boolean),...t.filter(u=>!c.includes(u.name))]}function T({adapters:t,preferredWallets:c=[W]}){const u=new Set;let r=null,n={accounts:[],currentAccount:null,wallets:w(d(t),c),currentWallet:null,status:"DISCONNECTED"};const i=()=>({...n,isConnecting:n.status==="CONNECTING",isConnected:n.status==="CONNECTED",isError:n.status==="ERROR"});let o=i();function l(e){n={...n,...e},o=i(),u.forEach(s=>{try{s(o)}catch{}})}function E(){r&&(r(),r=null),l({status:"DISCONNECTED",accounts:[],currentAccount:null,currentWallet:null})}const f=t.filter(g);return f.length&&f.map(e=>e.on("changed",()=>{l({wallets:w(d(t),c)})})),{getState(){return o},subscribe(e){u.add(e);try{e(o)}catch{}return()=>{u.delete(e)}},async connect(e){var N,C;const s=(N=n.wallets.find(a=>a.name===e))!=null?N:null;if(l({currentWallet:s}),s&&!s.connecting){r&&r(),r=s.on("change",({connected:a})=>{a===!1&&E()});try{l({status:"CONNECTING"}),await s.connect(),l({status:"CONNECTED"});const a=await s.getAccounts();l({accounts:a,currentAccount:(C=a[0])!=null?C:null})}catch(a){console.log("Wallet connection error",a),l({status:"ERROR"})}}else l({status:"DISCONNECTED"})},async disconnect(){if(!n.currentWallet){console.warn("Attempted to `disconnect` but no wallet was connected.");return}await n.currentWallet.disconnect(),E()},signAndExecuteTransaction(e){if(!n.currentWallet)throw new Error("No wallet is currently connected, cannot call `signAndExecuteTransaction`.");return n.currentWallet.signAndExecuteTransaction(e)}}}export{T as c};
